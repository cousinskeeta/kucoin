# -*- coding: utf-8 -*-
"""coinscraper_V3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JoE4d6o6h_al59wK9I0IJaLhVhK64mTL
"""

# Commented out IPython magic to ensure Python compatibility.
import bs4
import requests
import pandas as pd
import time
import random
import math
import sqlite3
import numpy as np
from math import pi
import matplotlib.pyplot as plt
# %matplotlib inline
from bokeh.plotting import figure, output_file, show    
from google.colab import drive
from os import mkdir
from os.path import exists

class coinscrapper(object):
  today = None
  kucoin_list = []
  technical_data = []
  fundamental_data = []
  rsi_data = []
  names = []
  todays_RSI = []
  todays_price = []
  todays_date = []
  marketcaps = []
  volumes = []
  plots = []
  log = []
  test= None

  def __init__(self, today, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.today = today
    self.log.append("Loading client\n")
    self.connect_googleDrive()
  
  def connect_googleDrive(self):
    drive.mount('drive', force_remount=True)
    self.log.append("Connecting to Google Drive\n")

  def get_kc_list(self):
    today_ = self.today
    if len(self.kucoin_list) < 1:

      try:
        from selenium import webdriver
        options = webdriver.ChromeOptions()
        options.add_argument('user-agent= Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36')
        options.add_argument('-headless')
        options.add_argument('-no-sandbox')
        options.add_argument('-disable-dev-shm-usage')
        print("Selenium Webdriver Loaded.")
        urls = []
        with webdriver.Chrome('chromedriver',options=options) as wd:
            url = "https://coinmarketcap.com/exchanges/kucoin/"
            wd.get(url)
            def scroll_to_end(wd2, scroll_point = 'document.body.scrollHeight'):  
              for i in range(1,1000):
                  print(i,". Scrolling down page")
                  wd2.execute_script(f"window.scrollTo(0, {i*scroll_point});")
                  time.sleep(7) 
                  try:
                      load_more_button = wd2.find_element_by_xpath('//div[@class="cmc-markets-listing__load-more")')
                      if load_more_button:
                          load_more_button.click()
                          time.sleep(3) 
                  except:
                      break
            scroll_to_end(wd)
            elem = wd.find_elements_by_xpath("//tr//div//a[@class='cmc-link']")
            res = [j.get_attribute('href') for j in elem]   
            print(res)
            for k in res:
              if 'trade' not in k:
                urls.append(k)
        historic_urls = [l + 'historical-data/'+ f'?start=20200501&end={today_}' for l in set(urls)]
        print(historic_urls)
        tickers = [z.split("/")[4] for z in historic_urls]
        print(tickers)
        self.names = tickers
        self.kucoin_list = historic_urls
        days = [today_]*len(historic_urls)
        self.todays_date = days
        self.log.append("Successfully pulled link Kucoin assest from CMC\n")
        return historic_urls

      except:
        if len(self.kucoin_list) < 1:
          print('Selenium webdriver required to connect.\nDo you want to install the required packages?\ny/n' )
          x = input()
          if x == 'y':
            print ('okay. We will install the required packages.')
            import sys
            from subprocess import STDOUT, check_call
            import os
            check_call(['apt-get', 'update'],
                stdout=open(os.devnull,'wb'), stderr=STDOUT)

            check_call(['apt-get', 'install', '-y', 'chromium-chromedriver'],
                stdout=open(os.devnull,'wb'), stderr=STDOUT)
            check_call([sys.executable, '-m', 'pip', 'install', 
            'selenium'])
            check_call([sys.executable, '-m', 'pip', 'install', 
            'progress'])
            print('Packages installed.')
            self.get_kc_list()
            print(f'Success! {len(self.kucoin_list)} assets found.')
          else:
            print ('Sorry you need these packages to continue.\n Try again? y/n')
            y = input()
            if y == "y":
              self.get_kc_list()
              print(f'Success! {len(self.kucoin_list)} assets found.')
          self.log.append("Failed to get link Kucoin assest from CMC\n")
        else:
          print('We ran into a problem.\n Reconnecting...')
          self.get_kc_list()
          print(f'Success! {len(self.kucoin_list)} assets found.')
    else:
      print('Contact Developer.')

  def get_data(self):
    if len(self.kucoin_list) < 1:
      self.get_kc_list()
    series = self.kucoin_list
    time.sleep(random.uniform(5, 10))
    start = time.time()
    for idx, coins in enumerate(series):
      loop = time.time()
      print(idx+1,"out of ", len(series))
      try:
        data = pd.read_html(coins)
        self.technical_data.append(data[2])
        self.fundamental_data.append(data[3])
        time.sleep(random.uniform(7, 10))
        elapsed = loop - start
        print('Success!', elapsed, 'seconds...')
        self.log.append(f'{round(elapsed/60,2)} minutes elapsed...\n')
      except:
        self.technical_data.append("Error")
        self.fundamental_data.append("Error")
        time.sleep(random.uniform(7, 10))
        elapsed = loop - start
        print("Failed.", elapsed, 'seconds...')
        self.log.append(f'Ooopps.... Somebody hating. \nWe missing the one for {coins}, \n or CMC just did not have the data')
        self.log.append(f'{round(elapsed/60,2)} minutes elapsed...\n')

  def computeRSI (self, data, time_window):
    diff = data.diff(1).dropna()  
    up_chg = 0 * diff
    down_chg = 0 * diff
    up_chg[diff > 0] = diff[ diff>0 ]
    down_chg[diff < 0] = diff[ diff < 0 ]
    up_chg_avg   = up_chg.ewm(com=time_window-1 , min_periods=time_window).mean()
    down_chg_avg = down_chg.ewm(com=time_window-1 , min_periods=time_window).mean()
    rs = abs(up_chg_avg/down_chg_avg)
    rsi = 100 - 100/(1+rs)
    self.log.append("Computing RSI\n")
    return rsi

  def preprocess(self, df):
    data = df.copy()
    data['date_'] = pd.to_datetime(data['Date'])
    data.index = pd.DatetimeIndex(data['date_'])
    data.sort_index(ascending=True, inplace=True)
    self.log.append("Prepocessing data\n")
    return data

  def get_rsi_data(self, data):
    try:
      m = data.copy()
      x = self.preprocess(m)
      x['RSI'] = self.computeRSI(x['Close**'], 14)
      r = list(x['RSI'])[-1]
      p = list(x['Close**'])[-1]
      self.rsi_data.append(x)
      self.todays_RSI.append(r)
      self.todays_price.append(p)
      self.log.append("Collecing RSI data\n")
      return x
    except:
      return None

  def plot_rsi_data(self, data, title):
    title = title
    test = data 
    r = list(test['RSI'])[-1]
    print(f'Plotting RSI ({r}) for: ', f'{title}')
    fig = plt.figure(figsize=(40,9))
    plt.plot(test.index[-14:],test.RSI[-14:])
    plt.title(f'{title}'+"-Current-RSI-"+str(r))
    plt.hlines(80,xmin=test.index[-14:].min(),  xmax=test.index[-14:].max(),colors='k', label='80')
    plt.hlines(70,xmin=test.index[-14:].min(),  xmax=test.index[-14:].max(),colors='r', label='70', linestyles='dashdot')
    plt.hlines(30,xmin=test.index[-14:].min(),  xmax=test.index[-14:].max(),colors='g', label='30', linestyles='dashdot')
    plt.hlines(20,xmin=test.index[-14:].min(),  xmax=test.index[-14:].max(),colors='b', label='20')
    plt.xlabel('Date')
    plt.ylabel('RSI_14')
    plt.legend()
    plt.show();
    return fig


  def summary(self):
    if len(self.technical_data) < 1:
      self.get_data()
      self.pull_fundamentals()
    if len(self.todays_RSI) < 1:
      backup = [self.get_rsi_data(i) for i in self.technical_data]
      charts = [self.plot_rsi_data(j,k) for j,k in zip(backup,self.names)]
      # candles = [self.save_candlesticks(j,k) for j,k in zip(backup,self.names)]
      for i in charts:
        i.show();
        self.plots.append(i)
        try:
          for name in self.names:
            if not exists(f'/content/drive/My Drive/CoinScraper/charts/{name}/'):
              mkdir(f'/content/drive/My Drive/CoinScraper/charts/{name}/')
          save_plots = [i.savefig(f'/content/drive/My Drive/CoinScraper/charts/{k}/RSI-{self.today}.png', dpi=72) for k in self.names]
          self.plots.append(i)
          self.log.append(f"Saved plot data. \n")
        except: 
          raise Exception("""Make sure you have a folder named, 'CoinScraper', and also a sub-folder named "charts\n~/content/drive/My Drive/CoinScraper/charts/""")
          print('Please connect to google drive to save files.')
          self.connect_googleDrive()
          for name in self.names:
            if not exists(f'/content/drive/My Drive/CoinScraper/charts/{name}/'):
              mkdir(f'/content/drive/My Drive/CoinScraper/charts/{name}/')
          save_plots = [i.savefig(f'/content/drive/My Drive/CoinScraper/charts/{k}/RSI-{self.today}.png', dpi=72) for k in self.names]
          self.plots.append(i)
          self.log.append(f"Could not save plot data. \n")

    sum_table = pd.DataFrame()
    try:
      sum_table['Date'] = self.todays_date
      sum_table['Name'] = self.names
      sum_table['Price'] = self.todays_price
      sum_table['RSI'] = self.todays_RSI
      sum_table['MarketCap'] = self.marketcaps
      sum_table['Volume'] = self.volumes
      sum_table['URL'] = self.kucoin_list
      try:
        sum_table.sort_values('RSI').to_csv(f'/content/drive/My Drive/CoinScraper/summary-{self.today}.csv')
        self.log.append('Saving Data\n')
      except:
        self.connect_googleDrive()
        # sum_table.fillna(0, axis=1, inplace=True)
        sum_table.sort_values('RSI').to_csv(f'/content/drive/My Drive/CoinScraper/summary-{self.today}.csv')
      # with open(f'log-file{self.today}.txt',"w") as f:
      #     f.write("Woops! I have deleted the content!")
      #     f.close()
      # with open(f'/content/drive/My Drive/CoinScraper/summary-table-{self.today}.html', 'w') as fo:
      #   sum_table.to_html(fo)
      return sum_table.sort_values('RSI')
    except: 
      raise Exception('Error generating summary table')

  def pull_fundamentals(self):
    fund = self.fundamental_data
    for i in fund:
      try:
        marketcap = i.set_index(0).stack()[3]
        volume = i.set_index(0).stack()[4]
        self.marketcaps.append(marketcap)
        self.volumes.append(volume)
        self.log.append('Pulling fundamentals\n')
      except:
        self.marketcaps.append('Error')
        self.volumes.append('Error')
        self.log.append('Error pulling fundamentals\n')
      
  def load_html_page():
    pass


  def save_candlesticks(self, data, name):
    df = data
    name = name
    try:
      inc = df['Close**'] > df['Open*']
      dec = df['Open*'] > df['Close**']
      w = 12*60*60*1000 # half day in ms
      TOOLS = "pan,wheel_zoom,box_zoom,reset,save"
      p = figure(x_axis_type="datetime", tools=TOOLS, plot_width=1000, title = f"{name} Price Chart")
      p.xaxis.major_label_orientation = pi/4
      p.grid.grid_line_alpha=0.3
      p.segment(df.index, df['High'], df.index, df['Low'], color="black")
      p.vbar(df.index[inc], w, df['Open*'][inc], df['Close**'][inc], fill_color="#D5E1DD", line_color="black")
      p.vbar(df.index[dec], w, df['Open*'][dec], df['Close**'][dec], fill_color="#F2583E", line_color="black")
      output_file(f"/content/drive/My Drive/CoinScraper/charts/{name}/candle-stick-{self.today}.html", title=f"{name}-{self.today}")
      self.log.append(f'Plotting {name} candlesticks\n')
      show(p)  # open a browser
      self.candle_sticks.append(p)
    except:
      self.log.append(f'Error plotting candlesticks for {name}\n')

